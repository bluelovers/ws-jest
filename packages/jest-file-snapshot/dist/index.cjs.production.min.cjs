"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("fs-extra"),t=require("upath2"),n=require("filenamify"),a=require("jest-matcher-utils"),i=require("crlf-normalize"),s=require("path-in-dir"),o=require("@yarn-tool/find-root");function _interopDefaultLegacy(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r,l=_interopDefaultLegacy(n);exports.EnumUpdateSnapshot=void 0,(r=exports.EnumUpdateSnapshot||(exports.EnumUpdateSnapshot={})).none="none",r.new="new",r.all="all";const u={expand:!1,contextLines:5,aAnnotation:"Snapshot"};function isEqual(e,t){return Buffer.isBuffer(e)?e.equals(t):e===t}function getBaseSnapshotDirectory(e){return t.join(t.dirname(e.testPath),"__file_snapshots__")}function getBaseSnapshotFileName(e){return t.join(getBaseSnapshotDirectory(e),`${l.default(e.currentTestName,{replacement:"-"}).replace(/\s/g,"-")}-${e.assertionCalls}`)}function _hintSnapshotFileName(e,n){var a;const i=getBaseSnapshotDirectory(e);let r,l;if(s.pathInsideDirectory(n,i)?l=t.relative(i,n):(r=o.findRootLazy({cwd:e.testPath},!1),r&&(s.pathInsideDirectory(n,r.pkg)?l=t.relative(r.pkg,n):s.pathInsideDirectory(n,r.root)&&(l=t.relative(r.root,n)))),null===(a=l)||void 0===a||!a.length){let e=o.findRootLazy({cwd:t.dirname(n)},!1);l=null!=e&&e.pkg?t.relative(t.resolve(e.pkg,".."),n):n}return{snapshotFileName:n,snapshotDisplayName:l,rootData:r}}function toMatchFile(n,i,s={}){const{isNot:o,snapshotState:r}=this,l="toMatchFile",p=null!=i?i:getBaseSnapshotFileName(this),f=_hintSnapshotFileName(this,p).snapshotDisplayName;s={diff:Object.assign({},u,s.diff)};const h={isNot:o,promise:this.promise};if("none"===r._updateSnapshot&&!e.pathExistsSync(p))return r.unmatched++,{pass:o,message:()=>`New output file ${a.EXPECTED_COLOR(f)} was ${a.RECEIVED_COLOR("not written")}.\n\nThe update flag must be explicitly passed to write a new snapshot.\n\nThis is likely because this test is run in a ${a.EXPECTED_COLOR("continuous integration (CI) environment")} in which snapshots are not written by default.\n\n`,actual:n,name:l};let c,d=!1,message=()=>a.matcherHint(l,void 0,f,h);if(e.pathExistsSync(p))if(c=e.readFileSync(p,Buffer.isBuffer(n)?null:"utf8"),o)isEqual(n,c)?(r.unmatched++,d=!0):d=!1;else if(isEqual(n,c))d=!0;else if("all"===r._updateSnapshot)d=!0,e.outputFileSync(p,n),r.updated++;else{r.unmatched++;const e=_diffHint(c,n,s.diff);message=()=>a.matcherHint(l,void 0,f,h)+e}else d=!0,o||"new"!==r._updateSnapshot&&"all"!==r._updateSnapshot?(r.unmatched++,message=()=>`The output file ${a.EXPECTED_COLOR(t.basename(p))} ${a.RECEIVED_COLOR("doesn't exist")}.`):(e.outputFileSync(p,n),r.added++);return{pass:d,message,actual:n,expected:c,name:l}}function _diffHint(e,t,n){var s;if(Buffer.isBuffer(e)||Buffer.isBuffer(t))return"";null!==(s=n)&&void 0!==s||(n=u);let o=[""];return i.crlf(t)===i.crlf(e)?(o.push("Contents have differences only in line separators"),o.push(a.diff(i.chkcrlf(t),i.chkcrlf(e)))):o.push(a.diff(t,e,n)),o.join("\n\n")}var p={toMatchFile};exports._diffHint=_diffHint,exports._hintSnapshotFileName=_hintSnapshotFileName,exports.default=p,exports.getBaseSnapshotDirectory=getBaseSnapshotDirectory,exports.getBaseSnapshotFileName=getBaseSnapshotFileName,exports.toMatchFile=toMatchFile;
//# sourceMappingURL=index.cjs.production.min.cjs.map
